# Operating System
## [OSTEP 정리글](https://github.com/jaicoco/iOS_Study/tree/master/Operating_System)

### Q. 프로세스와 스레드의 차이점이 무엇인가요?
- 프로세스
  - 프로세스는 디스크에 존재하는 프로그램 중 메모리에 적재되어 CPU 할당을 받을 수 있는 상태인 프로그램을 말합니다. 각각의 프로세스는 독립적인 메모리 공간을 갖습니다.
- 스레드
  - 스레드는 프로세스의 실행 단위라고 할 수 있습니다. 하나의 프로세스는 여러개의 스레드를 실행할 수 있습니다. 각각의 스레드는 메모리에서 Stack을 제외한 Code, Data, Heap 부분을 공유하기 때문에 임계 영역에 접근 할 때에는 Lock, Semaphore를 활용하여 임계 영역에 대한 보호가 필요합니다.

### Q. CPU 스케줄러에 대하여 아는대로 말해보세요.
- 
### Q. 동기, 비동기의 차이가 무엇인가요?
-  동기 (Synchronous)
  - 어떤 작업들을 실행 했을 때 결과가 나올 때 까지 기다렸다가 다음 작업을 수행하는 방식입니다. 예를 들어 A, B, C의 작업이 있을 때 A를 수행했다면 A가 종료되기를 기다린 후 B, C를 수행할 수 있습니다. 따라서 순차적으로 작업들이 수행되며 하나의 작업이 실행 중 Block 상태가 되더라도 다른 작업을 수행할 수 없습니다.
-  비동기 (Asynchronous)
  - A, B, C 작업을 수행 할 때 병렬적으로 작업을 수행하는 것을 말합니다. 동기 방식과 다르게 다른 작업이 종료 되지 않았더라도 다른 작업을 수행할 수 있습니다. A 작업이 실행중 Block 상태가 되거나 Sleep 상태가 된다면 다른 작업을 수행하게 됩니다. 따라서 어떤 작업이 먼저 완료될지 알 수 없으며 작업이 완료되면 완료되었다는 알림을 받게 됩니다.  
### Q. 메모리를 관리 하는 방법 중 Segmentation 방법에 대해 설명해보세요
- 메모리를 사용 할 때 연속적으로 메모리를 할당하게 되면 heap과 stack 사이에 존재하는 사용하지 않는 공간이 낭비되는 문제점이 있었습니다. 32비트 컴퓨터에서는 이러한 방식으로 하나의 프로세스를 실해하면 주소 공간이 4GB에 이르러 메모리 낭비의 문제가 많았습니다. 이를 해결하기 위해 segmentation 방법이 등장했고, 메모리를 연속적으로 할당하는 것이 아닌 여러개의 segment라는 단위로 분할하여 할당하게 되었습니다. Paging 기법과의 차이점은 segment의 크기가 가변 크기라는 점입니다. 이러한 가변 크기의 segment를 처리하기 위해서는 하드웨어의 도움을 받아야합니다. Base, Size 레지스터를 지원받고 스택의 경우 거꾸로 확장되는 특징이 있기 때문에 확장 방향을 구분하는 레지스터도 필요합니다. 이러한 레지스터를 활용하여 자신의 메모리 공간이 아닌 다른 segment의 메모리 공간에 접근하는 것을 막아주며 혹시라도 접근할 경우 segmentation fault를 발생시킵니다. segmentation 방법은 segment가 가변 크기를 갖는다는 점에서 외부 단편화라는 문제가 발생하게 됩니다. 외부 단편화란 메모리의 여유공간이 필요한 공간보다 더 많음에도 불구하고 메모리 할당을 하지 못하는 문제입니다. 이러한 문제를 해결하기 위해선 메모리 압축이나 메모리 할당 방법들인 best fit, worst fit, first fit, next fit을 활용할 수 있지만 모든 방법이 완화를 할 수 있는 것이지 궁극적으로 해결하지는 못 한다는 문제가 있습니다.
### Q. 메모리를 관리 하는 방법 중 Paging 방법에 대해 설명해보세요
 - 페이징 기법은 메모리를 할당 할 때 연속적으로 할당하는 것이 아닌 page라는 단위로 쪼개서 할당하게 되고, segmentation기법과는 다르게 고정 크기의 공간으로 할당한다는 차이점이 있습니다. 고정 크기로 할당하기 때문에 외부 단편화 문제는 해결되지만 page의 크기를 크게 만들게 되면 내부 단편화라는 새로운 문제가 발생할 수 있기 때문에 페이지의 크기를 적절하게 결정하는 것이 중요합니다. 페이징 기법을 통해 주소변환을 하기 위해서는 가상 주소를 실제 주소로 변환하는 작업을 위한 page table이라는 것이 필요하게 되며, 많은 프로세스를 실행하게 되면 page table의 크기가 무시할 수 없는 수준으로 커지기 때문에 마냥 좋다고는 할 수 없습니다. 이러한 page table의 크기를 줄이는 방법에는 단순하게 page의 크기를 늘리는 방법이 있고 segmentation 기법과 함께 사용하는 방법, 멀티 레벨 page table을 사용하는 방법이 있습니다. 하지만 이렇게 하더라도 부족한 경우 디스크에 Page를 swap 하여 사용하게 됩니다. 
### Q. TLB는 무엇인가요?
 - 페이징 기법을 사용하게 될 때 주소 변환 과정은 메모리에 page table가 존재하는지 찾고 -> page table 정보를 통해 주소 변환을 하고 -> 실제 메모리에서 데이터를 가지고 오는 과정을 거치게 됩니다. 이 경우 메모리에 자주 접근하게 되고 이는 결국 오버헤드를 발생시킵니다. 따라서 CPU의 MMU에 위치한 TLB라는 녀석을 활용해서 메모리 접근을 줄이는 방법을 사용하게 됩니다. TLB를 사용하게 되면 page table을 메모리에서 먼저 찾는 것이 아닌 CPU의 TLB를 확인하여 정보가 있는지 확인합니다. 만약 없다면 그제서야 메모리에 접근하게 됩니다. 따라서 TLB에 최대한 많이 접근하는 방법이 좋으며 이러한 것은 cache 공간 지역성을 활용하여 좋게 만들 수 있습니다.
### Q. Swap 공간이 무엇인가요?

### Q. 스레드를 사용할 때 문제점은 무엇인가요?
 - 
### Q. 스레드를 사용할 때 발생하는 문제점을 해결하는 방법을 아는대로 말해주세요 (Lock, Semaphore)

### Q. Deadlock에 대해 아는대로 말해주세요.

 
